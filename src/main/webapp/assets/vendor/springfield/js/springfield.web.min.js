/**
 * @license
 * Copyright © 2017 ∑(O_O；).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

'use strict';

(function() {

  /**
   * A Javascript Punycode converter derived from example in RFC3492.
   * It it based on the C code in RFC 3492. To use it with domain names you have to remove/add
   * "xn--"" from/to the input/output to/from decode/encode.
   * This implementation is created by some@domain.name and released into public domain
   * 
   * @since 1.0.0
   * @instance
   * @see https://stackoverflow.com/questions/183485/converting-punycode-with-dash-character-to-unicode
   * @see http://www.ietf.org/rfc/rfc3492.txt
   */
  var punycode = new function Punycode() {
    // This object converts to and from puny-code used in IDN
    //
    // punycode.ToASCII ( domain )
    // 
    // Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    //
    // punycode.ToUnicode (domain)
    //
    // Converts a puny-coded domain name to unicode.
    // It only converts the puny-coded parts of the domain name.
    // I.e. it dosent matter if you call it on a string
    // that already has been converted to unicode.
    //
    //
    this.utf16 = {
      // The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.
      decode: function(input) {
        var output = [], i=0, len=input.length,value,extra;
        while (i < len) {
          value = input.charCodeAt(i++);
          if ((value & 0xF800) === 0xD800) {
            extra = input.charCodeAt(i++);
            if ( ((value & 0xFC00) !== 0xD800) || ((extra & 0xFC00) !== 0xDC00) ) {
              throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');
            }
            value = ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
          }
          output.push(value);
        }
        return output;
      },
      encode:function(input){
        var output = [], i=0, len=input.length,value;
        while (i < len) {
          value = input[i++];
          if ( (value & 0xF800) === 0xD800 ) {
            throw new RangeError('UTF-16(encode): Illegal UTF-16 value');
          }
          if (value > 0xFFFF) {
            value -= 0x10000;
            output.push(String.fromCharCode(((value >>>10) & 0x3FF) | 0xD800));
            value = 0xDC00 | (value & 0x3FF);
          }
          output.push(String.fromCharCode(value));
        }
        return output.join('');
      }
    }

    //Default parameters
    var initial_n = 0x80;
    var initial_bias = 72;
    var delimiter = '\x2D';
    var base = 36;
    var damp = 700;
    var tmin=1;
    var tmax=26;
    var skew=38;
    var maxint = 0x7FFFFFFF;

    // decode_digit(cp) returns the numeric value of a basic code 
    // point (for use in representing integers) in the range 0 to
    // base-1, or base if cp is does not represent a value.
    function decode_digit(cp) {
      return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base;
    }

    // encode_digit(d,flag) returns the basic code point whose value
    // (when used for representing integers) is d, which needs to be in
    // the range 0 to base-1. The lowercase form is used unless flag is
    // nonzero, in which case the uppercase form is used. The behavior
    // is undefined if flag is nonzero and digit d has no uppercase form. 
    function encode_digit(d, flag) {
      return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);
      //  0..25 map to ASCII a..z or A..Z 
      // 26..35 map to ASCII 0..9
    }

    //** Bias adaptation function **
    function adapt(delta, numpoints, firsttime ) {
      var k;
      delta = firsttime ? Math.floor(delta / damp) : (delta >> 1);
      delta += Math.floor(delta / numpoints);

      for (k = 0; delta > (((base - tmin) * tmax) >> 1); k += base) {
        delta = Math.floor(delta / ( base - tmin ));
      }
      return Math.floor(k + (base - tmin + 1) * delta / (delta + skew));
    }

    // encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,
    // uppercase if flag is nonzero, and returns the resulting code point.
    // The code point is unchanged if it is caseless.
    // The behavior is undefined if bcp is not a basic code point.
    function encode_basic(bcp, flag) {
      bcp -= (bcp - 97 < 26) << 5;
      return bcp + ((!flag && (bcp - 65 < 26)) << 5);
    }

    // Main decode
    this.decode=function(input,preserveCase) {
      // Dont use utf16
      var output=[];
      var case_flags=[];
      var input_length = input.length;

      var n, out, i, bias, basic, j, ic, oldi, w, k, digit, t, len;

      // Initialize the state: 
      n = initial_n;
      i = 0;
      bias = initial_bias;

      // Handle the basic code points: Let basic be the number of input code 
      // points before the last delimiter, or 0 if there is none, then
      // copy the first basic code points to the output.
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) basic = 0;

      for (j = 0; j < basic; ++j) {
        if(preserveCase) case_flags[output.length] = ( input.charCodeAt(j) -65 < 26);
        if ( input.charCodeAt(j) >= 0x80) {
          throw new RangeError('Illegal input >= 0x80');
        }
        output.push( input.charCodeAt(j) );
      }

      // Main decoding loop: Start just after the last delimiter if any
      // basic code points were copied; start at the beginning otherwise. 
      for (ic = basic > 0 ? basic + 1 : 0; ic < input_length; ) {

        // ic is the index of the next character to be consumed,

        // Decode a generalized variable-length integer into delta,
        // which gets added to i. The overflow checking is easier
        // if we increase i as we go, then subtract off its starting 
        // value at the end to obtain delta.
        for (oldi = i, w = 1, k = base; ; k += base) {
          if (ic >= input_length) {
            throw RangeError ('punycode_bad_input(1)');
          }
          digit = decode_digit(input.charCodeAt(ic++));

          if (digit >= base) {
            throw RangeError('punycode_bad_input(2)');
          }
          if (digit > Math.floor((maxint - i) / w)) {
            throw RangeError ('punycode_overflow(1)');
          }
          i += digit * w;
          t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;
          if (digit < t) { break; }
          if (w > Math.floor(maxint / (base - t))) {
            throw RangeError('punycode_overflow(2)');
          }
          w *= (base - t);
        }

        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi === 0);

        // i was supposed to wrap around from out to 0,
        // incrementing n each time, so we'll fix that now: 
        if ( Math.floor(i / out) > maxint - n) {
          throw RangeError('punycode_overflow(3)');
        }
        n += Math.floor( i / out ) ;
        i %= out;

        // Insert n at position i of the output: 
        // Case of last character determines uppercase flag: 
        if (preserveCase) { case_flags.splice(i, 0, input.charCodeAt(ic -1) -65 < 26); }
        output.splice(i, 0, n);
        i++;
      }
      if (preserveCase) {
        for (i = 0, len = output.length; i < len; i++) {
          if (case_flags[i]) {
            output[i] = (String.fromCharCode(output[i]).toUpperCase()).charCodeAt(0);
          }
        }
      }
      return this.utf16.encode(output);
    };

    //** Main encode function **
    this.encode = function (input,preserveCase) {
      //** Bias adaptation function **
      var n, delta, h, b, bias, j, m, q, k, t, ijv, case_flags;

      if (preserveCase) {
        // Preserve case, step1 of 2: Get a list of the unaltered string
        case_flags = this.utf16.decode(input);
      }

      // Converts the input in UTF-16 to Unicode
      input = this.utf16.decode(input.toLowerCase());

      var input_length = input.length; // Cache the length

      if (preserveCase) {
        // Preserve case, step2 of 2: Modify the list to true/false
        for (j=0; j < input_length; j++) {
          case_flags[j] = input[j] != case_flags[j];
        }
      }

      var output=[];

      // Initialize the state: 
      n = initial_n;
      delta = 0;
      bias = initial_bias;

      // Handle the basic code points: 
      for (j = 0; j < input_length; ++j) {
        if ( input[j] < 0x80) {
          output.push(
              String.fromCharCode(
                  case_flags ? encode_basic(input[j], case_flags[j]) : input[j]
              )
          );
        }
      }

      h = b = output.length;

      // h is the number of code points that have been handled, b is the
      // number of basic code points 
      if (b > 0) output.push(delimiter);

      // Main encoding loop: 
      //
      while (h < input_length) {
        // All non-basic code points < n have been
        // handled already. Find the next larger one: 
        for (m = maxint, j = 0; j < input_length; ++j) {
          ijv = input[j];
          if (ijv >= n && ijv < m) m = ijv;
        }

        // Increase delta enough to advance the decoder's
        // <n,i> state to <m,0>, but guard against overflow: 

        if (m - n > Math.floor((maxint - delta) / (h + 1))) {
          throw RangeError('punycode_overflow (1)');
        }
        delta += (m - n) * (h + 1);
        n = m;

        for (j = 0; j < input_length; ++j) {
          ijv = input[j];

          if (ijv < n ) {
            if (++delta > maxint) return Error('punycode_overflow(2)');
          }

          if (ijv == n) {
            // Represent delta as a generalized variable-length integer: 
            for (q = delta, k = base; ; k += base) {
              t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;
              if (q < t) break;
              output.push( String.fromCharCode(encode_digit(t + (q - t) % (base - t), 0)) );
              q = Math.floor( (q - t) / (base - t) );
            }
            output.push( String.fromCharCode(encode_digit(q, preserveCase && case_flags[j] ? 1:0 )));
            bias = adapt(delta, h + 1, h == b);
            delta = 0;
            ++h;
          }
        }

        ++delta, ++n;
      }
      return output.join('');
    }

    this.ToASCII = function ( domain ) {
      var domain_array = domain.split('.');
      var out = [];
      for (var i=0; i < domain_array.length; ++i) {
        var s = domain_array[i];
        out.push(
          s.match(/[^A-Za-z0-9-]/)
              ? 'xn--' + punycode.encode(s)
              : s
            );
        }
      return out.join('.');
    }
    this.ToUnicode = function ( domain ) {
        var domain_array = domain.split('.');
        var out = [];
        for (var i=0; i < domain_array.length; ++i) {
            var s = domain_array[i];
            out.push(
                s.match(/^xn--/) ?
                punycode.decode(s.slice(4)) :
                s
            );
        }
        return out.join('.');
    }
  }();

  /**
   * An browser detector that detects if the features are supported by the current browser.
   * It also caches the detection results.
   * 
   * **Note**: The BrowserDetector class is just a light weight feature detector. If you want
   * an complete, all-in-one library instead, try [Modernizr](https://modernizr.com).
   * 
   * @author ∑(O_O；)
   * @instance
   * @class
   * @see https://stackoverflow.com/questions/5222209/getter-setter-in-constructor
   */
  var browserDetector = new function BrowserDetector() {
    Object.defineProperties(this, {
      '_userAgent': {
        writable: true,
      },
      'userAgent': {
        get: function() {
          if (this._userAgent == null) {
            this._userAgent = window.navigator.userAgent.toLowerCase();
          }
          return this._userAgent;
        },
      },
      '_isIE': {
        writable: true,
      },
      'isIE': {
        get: function() {
          if (this._isIE == null) {
            this._isIE = this.userAgent && /msie|trident/.test(this.userAgent);
          }
          return this._isIE;
        },
      },
      '_isEdge': {
        writable: true,
      },
      'isEdge': {
        get: function() {
          if (this._isEdge == null) {
            this._isEdge = this.userAgent && this.userAgent.includes('edge/');
          }
          return this._isEdge;
        },
      },
      '_isFirefox': {
        writable: true,
      },
      'isFirefox': {
        get: function() {
          if (this._isFirefox == null) {
            this._isFirefox = this.userAgent && this.userAgent.includes('firefox/');
          }
          return this._isFirefox;
        },
      },
      '_isChrome': {
        writable: true,
      },
      'isChrome': {
        get: function() {
          if (this._isChrome == null) {
            this._isChrome = this.userAgent && this.userAgent.includes('chrome/');
          }
          return this._isChrome;
        },
      },
      '_isAndroid': {
        writable: true,
      },
      'isAndroid': {
        get: function() {
          if (this._isAndroid == null) {
            this._isAndroid = this.userAgent && this.userAgent.includes('android');
          }
          return this._isAndroid;
        },
      },
      '_isIOS': {
        writable: true,
      },
      'isIOS': {
        get: function() {
          if (this._isIOS == null) {
            this._isIOS = this.userAgent && /iphone|ipad|ipod|ios/.test(this.userAgent);
          }
          return this._isIOS;
        },
      },
      '_isURLAvailable': {
        writable: true,
      },
      'isURLAvailable': { // Note: This is an experimental technology
        get: function() {
          if (this._isURLAvailable == null) {
            this._isURLAvailable = typeof URL != 'undefined' && !this.isIE; // As of IE11, instantiating new URL objects is not supported - ie. new URL() does not work.
          }
          return this._isURLAvailable;
        },
      },
      '_isURLSearchAvailable': {
        writable: true,
      },
      'isURLSearchAvailable': { // Note: This is an experimental technology
        get: function() {
          if (this._isURLSearchAvailable == null) {
            this._isURLSearchAvailable = this.isURLAvailable && Object.keys(URL.prototype).includes('search');
          }
          return this._isURLSearchAvailable;
        },
      },
      '_isURLSearchhParamsAvailable': {
        writable: true,
      },
      'isURLSearchhParamsAvailable': { // Note: This is an experimental technology
        get: function() {
          if (this._isURLSearchhParamsAvailable == null) {
            this._isURLSearchhParamsAvailable = this.isURLAvailable && Object.keys(URL.prototype).includes('searchParams');
          }
          return this._isURLSearchhParamsAvailable;
        },
      },
      '_isPostMessageAvailable': {
        writable: true,
      },
      'isPostMessageAvailable': {
        get: function() {
          if (this._isPostMessageAvailable == null) {
            this._isPostMessageAvailable = !!window.postMessage;
          }
          return this._isPostMessageAvailable;
        },
      },
      '_isDragAndDropAvailable': {
        writable: true,
      },
      'isDragAndDropAvailable': {
        get: function() {
          if (this._isDragAndDropAvailable == null) {
            this._isDragAndDropAvailable = 'draggable' in document.createElement('span');
          }
          return this._isDragAndDropAvailable;
        },
      },
      '_isFileAvailable': {
        writable: true,
      },
      'isFileAvailable': {
        get: function() {
          if (this._isFileAvailable == null) {
            this._isFileAvailable = typeof FileReader != 'undefined';
          }
          return this._isFileAvailable;
        },
      },
      '_isGeolocationAvailable': {
        writable: true,
      },
      'isGeolocationAvailable': {
        get: function() {
          if (this._isGeolocationAvailable == null) {
            this._isGeolocationAvailable = !!window.navigator.geolocation;
          }
          return this._isGeolocationAvailable;
        },
      },
      '_isHistoryAvailable': {
        writable: true,
      },
      'isHistoryAvailable': {
        get: function() {
          if (this._isHistoryAvailable == null) {
            this._isHistoryAvailable = !!(window.history && window.history.pushState);
          }
          return this._isHistoryAvailable;
        },
      },
      '_isBackAvailable': {
        writable: true,
      },
      'isBackAvailable': {
        get: function() {
          if (this._isBackAvailable == null) {
            this._isBackAvailable = this.isHistoryAvailable && window.history.length > 1;
          }
          return this._isBackAvailable;
        },
      },
      '_isLocalStorageAvailable': {
        writable: true,
      },
      'isLocalStorageAvailable': {
        get: function() {
          if (this._isLocalStorageAvailable == null) {
            this._isLocalStorageAvailable = (function() {
              try {
                return 'localStorage' in window && window['localStorage'] !== null;
              } catch(e) {
                return false;
              }
            })();
          }
          return this._isLocalStorageAvailable;
        },
      },
      '_isMicrodataAvailable': {
        writable: true,
      },
      'isMicrodataAvailable': {
        get: function() {
          if (this._isMicrodataAvailable == null) {
            this._isMicrodataAvailable = !!document.getItems;
          }
          return this._isMicrodataAvailable;
        },
      },
      '_isSessionStorageAvailable': {
        writable: true,
      },
      'isSessionStorageAvailable': {
        get: function() {
          if (this._isSessionStorageAvailable == null) {
            this._isSessionStorageAvailable = (function() {
              try {
                return 'sessionStorage' in window && window['sessionStorage'] !== null;
              } catch(e) {
                return false;
              }
            })();
          }
          return this._isSessionStorageAvailable;
        },
      },
      '_isCORSAvailable': {
        writable: true,
      },
      'isCORSAvailable': {
        get: function() {
          if (this._isCORSAvailable == null) {
            this._isCORSAvailable = 'withCredentials' in new XMLHttpRequest;
          }
          return this._isCORSAvailable;
        },
      },
      '_isFormDataAvailable': {
        writable: true,
      },
      'isFormDataAvailable': {
        get: function() {
          if (this._isFormDataAvailable == null) {
            this._isFormDataAvailable = !!FormData;
          }
          return this._isFormDataAvailable;
        },
      },
    });
  }();

  /**
   * A string that indicates the context path of the web site. 
   * 
   * **Note:** Does only work for the "root" context path. Does not work with "subfolders",
   * or if context path has a slash (`"/"`) in it. An alternative solution is that burns a `<script>`
   * tag into the JSP that sets it in a GLOBAL variable:
   * ```
   * <script>
   *   var CONTEXT_PATH = "${pageContext.request.contextPath}"
   * </script>
   * ```
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @constant
   * @memberof Springfield
   * @type {String}
   * @see https://stackoverflow.com/questions/6615641/how-do-you-get-the-contextpath-from-javascript-the-right-way
   */
  var contextPath = window.location.pathname.substring(0, window.location.pathname.indexOf("/", 2));

  //  Used to map characters to HTML entities.
  var htmlEscapes = Object.create(null, { // TODO 不要";"？
      '&': { value: '&amp', enumerable: true },
      '<': { value: '&lt', enumerable: true },
      '>': { value: '&gt', enumerable: true },
      '"': { value: '&quot', enumerable: true },
      "'": { value: '&#39', enumerable: true },
  });

  // Used to match HTML entities and HTML characters.
  var unescapedHtmlPattern = /[&<>"']/g;
  var hasUnescapedHtmlPattern = RegExp(unescapedHtmlPattern.source);

  // Used to map HTML entities to characters.
  var htmlUnescapes = Object.create(null, {
      '&amp;': { value: '&', enumerable: true },
      '&lt;': { value: String.fromCharCode(60), enumerable: true },
      '&gt;': { value: '>', enumerable: true },
      '&quot;': { value: '"', enumerable: true },
      '&#39;': { value: "'", enumerable: true },
  });

  // Used to match HTML entities and HTML characters.
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g
  var reHasEscapedHtml = RegExp(reEscapedHtml.source)

  // A default options for `isURLLikeString` method.
  var defaultUrlOptions = Object.create(null, {
    // must be lower-case
    'schemes': { value: ['http', 'https', 'ftp'], enumerable: true, writable: true },
    // TODO must be lower-case?
    'tlds':  { value: ['com', 'org'], enumerable: true, writable: true },
    'requireValidScheme': { value: true, enumerable: true, writable: true },
    'requireValidTLD': { value: false, enumerable: true, writable: true },
    // no scheme, but star with "//"
    'allowSchemeRelativeURLs': { value: false, enumerable: true, writable: true },
    // for urls like http://localhost:8080/
    'allowLocalHosts': { value: true, enumerable: true, writable: true },
    // no scheme, no authority, and the path must be zero or more URL-path-segment strings,
    // separated from each other by "/", and not start with "/".
    'allowPathRelativeURLs': { value: false, enumerable: true, writable: true },
  });

  // $2: scheme (protocol)
  // $4: authority (userInfo & host)
  // $5: path
  // $7: query
  // $9: fragment
  //                            12            3  4          5       6   7        8 9
  var urlPattern = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?'); // 因为正则表达式中含有//，会被js引擎当成注释，不宜用/.../方式声明

  // generic scheme pattern
  var schemePattern = /^[a-z][a-z0-9\+\-\.]*/;

  // Do this as separate match because : could cause ambiguity with port prefix.
  var ipv6Format = '[0-9a-fA-F:]+';

  // RFC3986: userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
  // unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
  // sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
  // We assume that password has the same valid chars as user info
  var userInfoCharsFormat = "[A-Za-z0-9%-._~!$&'()*+,;=]";

  // Since neither ':' nor '@' are allowed chars, we don't need to use non-greedy matching
  var userInfoFormat
      = userInfoCharsFormat + '+' // at least one character for the name
      + '(?::' + userInfoCharsFormat + '*)?@'; // colon and password may be absent

  // allows for IPv4 but not IPv6
  var authorityCharsFormat = 'A-Za-z0-9%\-\.';

  // full-version: /([a-zA-Z0-9%-._~!$&'()*+,;=]+(?::[a-zA-Z0-9%-._~!$&'()*+,;=]*)?@)?(?:\[([0-9a-fA-F:]+)\]|([A-Za-z0-9-.]*))(?::(\d*))?(.*)?/
  // $1: userInfo
  // $2: ipv6
  // $3: ipv4 or hostname
  // $4: port, excludes leading colon
  // $5: extra, should always be empty. The code currently allows spaces.
  //                                 1    e.g. user:pass@           2                       3                                     4       5
  var authorityPattern = new RegExp('(' + userInfoFormat + ')?(?:\\[(' + ipv6Format + ')\\]|([' + authorityCharsFormat + ']*))(?::(\\d*))?(.*)?');

  // A IPv4 address segment must be a 32bit unsigned integer (0 - 255), and leading zeros is disallowed.
  var ipv4SegmentFormat = '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])';

  // RFC791: ipadress = ipsegment{3}.ipsegment
  // https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
  var ipv4Pattern = new RegExp('^(?:' + ipv4SegmentFormat + '\\.){3}(?:' + ipv4SegmentFormat + ')$');

  // only ascii chars allowed
  var asciiPattern = /^[\u0000-\u007F]+$/;
  var iso88591Pattern = /%[0-9A-Fa-f]{2}/;

  // Regular expression strings for hostnames (derived from RFC2396 and RFC1123)

  // RFC2396: domainlabel = alphanum | alphanum *( alphanum | "-" ) alphanum
  // Max 63 characters
  // It seems that "?>" cannot be recognized by js, so I have to replace it with another capture group ("?:").
  var domainlabelFormat = '[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?';

  // RFC2396: toplabel = alpha | alpha *( alphanum | "-" ) alphanum
  // Max 63 characters
  // For the same reason, "?>" here is also replaced. It may lead to low performance if the checking string is too lang.
  // See the links shown below for more details:
  // http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html
  // https://stackoverflow.com/questions/50524/what-is-a-regex-independent-capturing-group
  // http://blog.csdn.net/zfq642773391/article/details/5555602
  var toplabelFormat = '[A-Za-z](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?';
  
  // RFC2396: hostname = *( domainlabel "." ) toplabel [ "." ]
  // Note that the regex currently requires both a domain label and a top level label, whereas
  // the RFC does not. This is because the regex is used to detect if a TLD is present.
  // If the match fails, input is checked against domainlabelFormat (tldLessHostNamePattern).
  // RFC1123 sec 2.1 allows hostnames to start with a digit
  var hostNamePattern = new RegExp('^(?:' + domainlabelFormat + '\\.)+' + '(' + toplabelFormat + ')\\.?$');
  var tldLessHostNamePattern = new RegExp(domainlabelFormat);

  // widely used "local" domains (localhost or localdomain)
  var localTLDs = [
    'localhost', // RFC2606 defined
    'localdomain', // also widely used as localhost.localdomain
  ];

  // path pattern, excludes empty path
  var absolutePathPattern = /^(\/[-\w:@&?=+,.!/~*'%$_;\(\)]*)?$/;
  var relativePathPattern = /^([-\w:@&?=+,.!~*'%$_;\(\)][-\w:@&?=+,.!/~*'%$_;\(\)]*)?$/;

  /**
   * A method that converts the characters `"&"`, `"<"`, `">"`, `'"'`, and `"'"` in string to their
   * corresponding HTML entities.
   * 
   * **Note:** No other characters are escaped. To escape additional characters use a third-party library
   * like [_he_](https://mths.be/he).
   * 
   * Though the `">"` character is escaped for symmetry, characters like `">"` and `"/"` don't need escaping
   * in HTML and have no special meaning unless they're part of a tag or unquoted attribute value.
   * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   * 
   * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
   * to reduce XSS vectors.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {String} [string] The string to escape.
   * @returns {String} The escaped string.
   * @example
   * 
   * _.escape('fred, barney, & pebbles')
   * // => 'fred, barney, &amp pebbles'
   */
  function escape(string) {
    return (string && hasUnescapedHtmlPattern.test(string))
        ? String(string).replace(unescapedHtmlPattern, function(chr) { return htmlEscapes[chr]; })
        : string;
  }

  /**
   * The inverse of `escape`this method converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;` and
   * `&#39;` in `string` to their corresponding characters.
   * 
   * **Note:** No other HTML entities are unescaped. To unescape additional HTML entities use a third-party
   * library like [_he_](https://mths.be/he).
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {String} [string] The string to unescape.
   * @returns {String} Returns the unescaped string.
   * @example
   * 
   * _.unescape('fred, barney, &amp; pebbles')
   * // => 'fred, barney, & pebbles'
   */
  function unescape(string) {
    return (string && reHasEscapedHtml.test(string))
        ? String(string).replace(reEscapedHtml, function(entity) { return htmlUnescapes[entity]; })
        : string
  }

  /**
   * An internal method that checks if the given scheme is valid.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} scheme The scheme to check.
   * @param {String} url The URL that contains the checking scheme.
   * @param {*} [options] Options for checking.
   * @returns {Boolean} `True` if the given scheme is valid, `false` otherwise.
   */
  function isValidScheme(scheme, url, options) {
    if (scheme == null) {
      if (options.allowSchemeRelativeURLs && url.startsWith('//')) {
        return true;
      }
      if (options.allowPathRelativeURLs) {
        return true;
      }
      return false;
    }

    if (!schemePattern.test(scheme)) {
      return false;
    }

    if (options.requireValidScheme && !options.schemes.includes(scheme)) {
      return false;
    }

    return true;
  }

  /**
   * An internal method that checks if the given IP address is valid .
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} ip The IP adress to check.
   * @param {String|Number} [version] The version (4 or 6) of IP adress.
   * @returns {Boolean} `True` if the given IP address is valid, `false` otherwise.
   */
  function isValidIP(ip, version) {
    if (ip == null) {
      return false;
    }
    if (!version) {
      return isValidIP(string, '4') || isValidIP(string, '6');
    }

    ip = String(ip);
    version = String(version);

    if (version === '4') {
      return ipv4Pattern.test(ip);
    }

    var containsCompressedZeroes = ip.contains('::');
    if (containsCompressedZeroes && (ip.indexOf('::') !== ip.lastIndexOf('::'))) {
      return false;
    }
    if ((ip.startsWith(':') && !ip.startsWith('::'))
        || (ip.endsWith(':') && !ip.endsWith('::'))) {
      return false;
    }

    var octets = ip.split(':');
    if (containsCompressedZeroes) {
      if (ip.endsWith('::')) {
        // String.prototype.split() drops ending empty segments
        octets.push('');
      } else if (ip.startsWith('::') && octets.length > 0) {
        octets.shift();
      }
    }
    if (octets.length > 8/*max number of hex groups (separated by :) in an IPV6 address*/) {
      return false;
    }

    var validOctets = 0;
    var emptyOctets = 0; // consecutive empty chunks
    for (var index = 0; index < octets.length; index++) {
      var octet = octets[index];
      if (octet.length === 0) {
        emptyOctets++;
        if (emptyOctets > 1) {
          return false;
        }
      } else {
        emptyOctets = 0;
        // Is last chunk an IPv4 address?
        if (index === octets.length - 1 && octet.includes('.')) {
          if (!isValidIP(octet, '4')) {
            return false;
          }
          validOctets += 2;
          continue;
        }
        if (octet.length > 4/*max hex digits in each IPv6 group*/) {
          return false;
        }
        var octetInt = Number.parseInt(octet, 16);
        if (Number.isNaN(octetInt)) {
          return false;
        }
        if (octetInt < 0 || octetInt > 0xffff/*max unsigned short*/) {
          return false;
        }
      }
      validOctets++;
    }
    if (validOctets > 8/*max number of hex groups (separated by :) in an IPV6 address*/
        || (validOctets < 8 && !containsCompressedZeroes)) {
      return false;
    }

    return true;
  }

  /**
   * An internal method that checks if the given hostname is valid.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} hostName The hostname to check.
   * @param {*} [options] Options for checking.
   * @returns {Boolean} `True` if the given hostname is valid, `false` otherwise.
   */
  function isValidHostName(hostName, options) {
    if (hostName == null) {
      return false;
    }

    hostName = String(hostName);

    // To check a hostname within non-ascii chars, encode the hostname to IDNA (rather than ISO-8859-1) first.
    if (asciiPattern.test(hostName)) {
      if (iso88591Pattern.test(hostName)) {
        hostName = punycode.ToASCII(decodeURI(hostName)); // maybe hostname has been encoded to ISO-8859-1 by the caller (isValidAuthority)
      }
    } else {
      hostName = punycode.ToASCII(hostName); // IDNA encode
    }

    // Hosts must be equally reachable via punycode and Unicode;
    // Unicode is never shorter than punycode, so check punycode.
    // If domain did not convert, then it will be caught by ASCII
    // checks in the regexes below
    if (hostName.length > 253) { // 253: max hostname length
      return false;
    }

    var hostNamePhases = hostNamePattern.exec(hostName);
    if (hostNamePhases != null && hostNamePhases.length > 0) {
      var tld = hostNamePhases[1];
      if (options.allowLocalHosts && localTLDs.includes(tld)) {
        return true;
      }
      if (options.requireValidTLD) {
        return options.tlds.includes(tld);
      }
    }
    return options.allowLocalHosts && tldLessHostNamePattern.test(hostName);
  }

  /**
   * An internal method that checks if the given authority is valid.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} authority The authority to check.
   * @param {String} [scheme] The scheme of the URL which contains the checking authority.
   * @param {*} [options] Options for checking.
   * @returns {Boolean} `True` if the given authority is valid, `false` otherwise.
   */
  function isValidAuthority(authority, scheme, options) {
    if (authority == null) {
      return options.allowPathRelativeURLs;
    }
    if (authority == '' && scheme === 'file') {
      return true; // Special case - file: allows an empty authority.
    }

    // convert to ASCII if non-ascii characters present
    if (!asciiPattern.test(authority)) {
      authority = encodeURI(authority); // do not use encodeURIComponent since it encodes every non-ascii chars including "@" and ":"
    }

    var authorityPhases = authorityPattern.exec(authority);
    if (authorityPhases == null) {
      return false;
    }

    var userInfo = authorityPhases[1];
    if (userInfo != null) {
      if (scheme === 'file') {
        return false; // A URL cannot have a username/password if its scheme is "file".
      }
      // drop through to continue validation
      // 没必要再检查用户名和密码，如果其中含有非法字符，这些字符会被host匹配组捕获。而host合法字符的范围更小，可以一并发现并处理，大概吧
    }

    // We have to process IPv6 separately because that is parsed in a different group.
    // Note that hostname means ip or domain, and host means hostname + ":" + port.
    var hostName = authorityPhases[2];
    if (hostName != null) {
      if (!isValidIP(hostName, 6)) {
        return false;
      }
    } else {
      hostName = authorityPhases[3];

      // check if authority is hostname or IP address:
      // try a hostname first since that's much more likely
      if (!isValidHostName(hostName, options)) {
        // try an IPv4 address
        if (!isValidIP(hostName, 4)) {
          // isn't IPv4, so the URL is invalid
          return false;
        }
      }
    }

    var port = authorityPhases[4];
    if (port != null) {
      if (!/^[0-9]+$/.test(port)) {
        return false;
      }
      var portNumber = Number.parseInt(port);
      if (portNumber < 0 || portNumber > 65535) { // port range: 0 ~ 65535 (0xFFFF, max unsigned 16bit int)
        return false;
      }
    }

    var extra = authorityPhases[5];
    if (extra != null && extra.trim().length > 0) {
      return false;
    }

    return true;
  }

  /**
   * An internal method that normalizes the URL's path in a manner consistent with [RFC 2396](http://www.ietf.org/rfc/rfc2396.txt),
   * section 5.2, step 6,sub-steps c through f; that is:
   * 1. All "." segments are removed.
   * 1. If a ".." segment is preceded by a non-".." segment then both of these segments are removed.
   * This step is repeated until it is no longer applicable.
   * 
   * **Note:** This method is derived from
   * [`path.normalizeStringPosix`]( https://github.com/nodejs/node/blob/master/lib/path.js) method of NodeJS.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} path The path to normalize.
   * @param {Boolean} [allowAboveRoot] A flag that indicates if above root is allowed.
   *                                 If true, the leading ".." segment or a ".." segment which is preceded by
   *                                 another ".." segment will be preserved.
   * @returns {String} The normalized path (without leading slash) or the given path itself if it is null or empty.
   * @see http://www.ietf.org/rfc/rfc2396.txt
   * @example
   * 
   * _.normalizePathPosix('/path/../something/./identify')
   * // => 'something/identify'
   * 
   * _.normalizePathPosix('/../path/../something/./identify', true)
   * // => '../something/identify'
   */
  function normalizePathPosix(path, allowAboveRoot) {
    if (path == null) {
      return path;
    }
    path = String(path);
    if (path.length === 0) {
      return path;
    }

    var res = '';
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (code === 47/*/*/) {
        break;
      } else {
        code = 47/*/*/;
      }
      if (code === 47/*/*/) {
        if (lastSlash === i - 1 || dots === 1) {
          // NOOP
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2
              || res.charCodeAt(res.length - 1) !== 46/*.*/
              || res.charCodeAt(res.length - 2) !== 46/*.*/) {
            if (res.length > 2) {
              var start = res.length - 1;
              var j = start;
              for (; j >= 0; --j) {
                if (res.charCodeAt(j) === 47/*/*/) {
                  break;
                }
              }
              if (j !== start) {
                if (j === -1) {
                  res = '';
                } else {
                  res = res.slice(0, j);
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = '';
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += '/..';
            } else {
              res = '..';
            }
          }
        } else {
          if (res.length > 0) {
            res += '/' + path.slice(lastSlash + 1, i);
          } else {
            res = path.slice(lastSlash + 1, i);
          }
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46/*.*/ && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  /**
   * A method that normalizes the URL's path.
   * 
   * **Note:** This method is derived from
   * [`path.normalize`]( https://github.com/nodejs/node/blob/master/lib/path.js) method of NodeJS.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {String} path The path to normalize.
   * @returns {String} The normalized path or the given path itself if it is nullish.
   * @example
   * 
   * _.normalizePath()
   * // => undefined
   * 
   * _.normalizePath(null)
   * // => null
   * 
   * _.normalizePath('')
   * // => '.'
   * 
   * _.normalizePath('/')
   * // => '/'
   * 
   * _.normalizePath('path')
   * // => 'path'
   * 
   * _.normalizePath('/path/../something/./identify')
   * // => '/something/identify'
   */
  function normalizePath(path) {
    if (path == null) {
      return path;
    }
    path = String(path);

    if (path.length === 0) {
      return '.';
    }

    var isAbsolute = path.charCodeAt(0) === 47/*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;

    // Normalize the path
    path = normalizePathPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) {
      path = '.';
    }
    if (path.length > 0 && trailingSeparator) {
      path += '/';
    }
    if (isAbsolute) {
      return '/' + path;
    }
    return path;
  }

  /**
   * An internal method that checks if the given path is valid.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @param {String} path The path to check.
   * @param {String} [authority] The authority of the URL which contains the checking path.
   * @param {*} [options] Options for checking.
   * @returns {Boolean} `True` if the given path is valid, `false` otherwise.
   */
  function isValidPath(path, authority, options) {
    if (path == null) {
      return false;
    }
    if (path === '' && options.allowPathRelativeURLs) {
      return true;
    }
    if (path.startsWith("//") && authority != null) { // rfc3986 section 3.3
      return false;
    }
    
    // convert to ASCII if non-ascii characters present
    if (!asciiPattern.test(path)) {
      path = encodeURI(path);
    }

    var isPath = false;
    if (options.allowPathRelativeURLs) {
      isPath = absolutePathPattern.test(path) || relativePathPattern.test(path);
    } else {
      isPath = absolutePathPattern.test(path);
    }
    if (!isPath) {
      return false;
    }

    // process the "." segments and ".." segments
    path = normalizePathPosix(path, true);
    if (path.startsWith('../')/*trying to go via the parent dir*/
        || path === '..'/*trying to go to the parent dir*/) {
      return false;
    }

    return true;
  }

  /**
   * A method that checks if the given string is url-like. A string is considered url-like if
   * it has a valid format of URL.
   * 
   * **Note:** This method is derived from
   * [`UrlValidator.isValid`](https://github.com/apache/commons-validator/blob/trunk/src/main/java/org/apache/commons/validator/routines/UrlValidator.java).
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {String} string The string to check.
   * @param {*} [options] Options for checking.
   * @returns {Boolean} `True` if the given string is valid, `false` otherwise.
   * @see https://url.spec.whatwg.org/
   * @see http://www.ietf.org/rfc/rfc3986.txt
   * @see http://www.ietf.org/rfc/rfc2396.txt
   * @see http://www.ietf.org/rfc/rfc1123.txt
   * @example
   * 
   * _.isURLLikeString('https://developer.mozilla.org/en-US/docs')
   * // => true
   * 
   * _.isURLLikeString('/en-US/docs')
   * // => false
   * 
   * _.isURLLikeString('/en-US/docs', { allowPathRelativeURLs: true })
   * // => true
   * 
   * _.isURLLikeString('123')
   * // => false
   */
  function isURLLikeString(string, options) {
    if (string == null) {
      return false;
    }
    string = String(string);
    if (string.length >= 2083 || /[\s<>]/.test(string)) {
      return false;
    }
    if (string.startsWith('mailto:')) { // disallow mail adress for now
      return false;
    }

    options = Object.assign(Object.create(null), defaultUrlOptions, options);
    var urlPhases = urlPattern.exec(string);
    if (urlPhases == null) {
      return false;
    }

    var scheme = urlPhases[2];
    var authority = urlPhases[4];
    var path = urlPhases[5];
    return isValidScheme(scheme, string, options)
        && isValidAuthority(authority, scheme, options)
        && isValidPath(path, authority, options);
  }

  /**
   * A method that checks if the given value is classified as a `URL` object.
   * 
   * **Note:** It is not recommended to use this technology because it's specification has not
   * stabilized. Also note that the syntax and behavior of an experimental technology is subject
   * to change in future versions of browsers as the specification changes.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {*} value The value to check.
   * @returns {Boolean} `True` if the given value is url, `false` otherwise.
   * @example
   * 
   * _.isURL(new URL('https://github.com/apache/commons-validator'))
   * // => true
   * 
   * _.isURL(123)
   * // => false
   */
  function isURL(value) {
    return typeof value === 'object'
        && value !== null
        && Object.prototype.toString.call(value) === '[object URL]';
  }

  /**
   * A method that attempts to get the query of the given URL.
   * A query (also called query string) is [USVString](https://developer.mozilla.org/en-US/docs/Web/API/USVString)
   * containing a '?' followed by the parameters of the URL.
   * 
   * **Note:** If the given URL is `null` or `undefined`, then `window.location.search` is returned.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {URL|String} [url] The URL to fetch from.
   * @returns {String} Returns the query of the given URL if query presents, else ''.
   * @example
   * 
   * _.getQuery('https://developer.mozilla.org/en-US/docs/Web/API/URL')
   * // => ''
   * 
   * _.getQuery('https://developer.mozilla.org/en-US/docs/Web/API/URL?')
   * // => ''
   * 
   * _.getQuery('https://developer.mozilla.org/en-US/docs/Web/API/URL?q')
   * // => '?q'
   * 
   * _.getQuery('https://developer.mozilla.org/en-US/docs/Web/API/URL?q=1')
   * // => '?q=1'
   * 
   * _.getQuery()
   * // => '?q=1' (Assume that the URL of the current page is https://developer.mozilla.org/en-US/docs/Web/API/URL?q=1')
   */
  function getQuery(url) {
    if (url == null) {
      return window.location.search;
    }

    if (isURL(url) && browserDetector.isURLSearchSupported) {
      return url.search; // Note: May rise a cross browser compatibility risk. If true, delete this piece of code.
    }

    var options = Object.create(null, {
        'requireValidScheme': { value: false, enumerable: true, writable: true },
        'allowSchemeRelativeURLs': { value: true, enumerable: true, writable: true },
        'allowPathRelativeURLs': { value: true, enumerable: true, writable: true },
    });
    if (!isURLLikeString(url, options)) {
      return '';
    }
    var urlPhases = urlPattern.exec(url);
    return !!urlPhases[7] ? urlPhases[6] : '';
  }

  /**
   * A simulation of URLSearchParams for those JavaScript engines which don't support it.
   * 
   * **Note:** Mthods entries(), keys(), and values() are unavailable since true iterables
   * can not be polyfilled. Mthod sort() is unavailable since there is no browser supports
   * this method yet.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @class
   * @param {String} query The query to parse out.
   */
  function URLSearchParamsSimulation(query) {
    var params = Object.create(null);

    if (query.length > 0) { // query must be an empty string or a leading "?" string
      var paires = query.split('&'); // TODO is there any "normalizeQuery" specification?
      paires.forEach(function(paire) {
        var nameValue = paire.split('=');
        var name = nameValue[0];
        var value = nameValue[1];

        if (!value) {
          if (name === '') {
            return;
          }
          value = '';
        }
        if (!!params[name]) {
          params[name][params[name].length] = value;
        } else {
          params[name] = [value];
        }
      });
    }

    Object.defineProperties(this, {
      'append': {
          value: function(name, value) {
            name = String(name);
            value = String(value);
            if (this.has(name)) {
              params[name][params[name].length] = value;
            } else {
              params[name] = [value];
            }
          },
          enumerable: true,
      },
      'delete': {
          value: function(name) {
            if (this.has(name)) {
              delete params[String(name)];
            }
          },
          enumerable: true,
      },
      'get': {
          value: function(name) {
            var values = this.getAll(name);
            return values != null && values.length > 0 ? values[0] : values;
          },
          enumerable: true,
      },
      'getAll': {
          value: function(name) {
            return params[String(name)];
          },
          enumerable: true,
      },
      'has': {
          value: function(name) {
            return !!this.getAll(name);
          },
          enumerable: true,
      },
      'set': {
          value: function(name, value) {
            params[String(name)] = [String(value)];
          },
          enumerable: true,
      },
      'toString': { // Deviate from browser's behavior: different output key-value paire order.
          value: function() {
            var entries = Object.keys(params).map(function(name) { // TODO polyfill map, forEach
              var paires = [];
              params[name].forEach(function(value) {
                paires[paires.length] = encodeURIComponent(name) + '=' + encodeURIComponent(value);
              });
              return paires.join('&');
            });
            return entries.join('&');
          },
          enumerable: true,
      },
    });
  }

  /**
   * A method that attempts to get the queryparams of the given URL.
   * 
   * A queryparams is a `URLSearchParams` or a `URLSearchParamsSimulation` object, which can make it
   * easy to parse out the parameters form the query.
   * 
   * **Note:** If the given URL is `null` or `undefined`, then a queryparams based on
   * `window.location.search` is returned.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {URL|String} [url] The URL to fetch from.
   * @returns {URLSearchParams|URLSearchParamsSimulation} Returns an `URLSearchParams` object if it is
   *                                                      natively supported, otherwise, an
   *                                                      `URLSearchParamsSimulation` object is returned.
   * @example
   * 
   * _.getQueryParams()
   * // => URLSearchParamsSimulation {append: function, delete: function, get: function, getAll: function, has: function…}
   */
  function getQueryParams(url) {
    if (isURL(url) && browserDetector.isURLSearchhParamsSupported) {
      return url.searchParams; // Note: May rise a cross browser compatibility risk. If true, delete this piece of code.
    }

    var query = getQuery(url);
    return new URLSearchParamsSimulation(query.slice(1));
  }

  /**
   * A method that navigates to a new page.
   * 
   * **Note:** Security settings, like CORS, may prevent this to effectively happen.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {String} url The URL of the new page.
   * @param {...*} args The arguments for formatting URL.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
   * @example
   * 
   * _.route('https://developer.mozilla.org/{0}/{1}/{2}', 'en-US', 'docs', 'Web')
   * // => navigated to https://developer.mozilla.org/en-US/docs/Web
   * 
   * function customizer(url, path, subpath) {
   *   return url.replace(/\{0\}/, path + '/' + subpath)
   * }
   * 
   * _.route('https://developer.mozilla.org/{0}', customizer, 'en-US', 'docs')
   * // => navigated to https://developer.mozilla.org/en-US/docs
   */
  function route(url, args) {
    if (url == null) {
      return;
    }

    url = String(url);
    if (arguments.length > 1) {

      // convert arguments to an array
      var args = Array.apply(null, arguments); // Using slice on arguments prevents optimizations in some JavaScript engines (e.g. V8).
      // remove url from arguments
      args.shift();

      var maybeFn = args[0]; // if customizer argument exists?
      if (Object.prototype.toString.call(maybeFn) === '[object Function]') {
        args.shift();
        args.unshift(url); // The url must be the first argument of the customizer.
        url = maybeFn.apply(null, args);
      } else {
        args.forEach(function(arg, index) {
          url = url.replace(new RegExp('\\{' + index + '\\}', 'g'), arg);
        });
      }
    }

    window.location.href = url;
  }

  /**
   * A method that resolves a sequence of paths or path segments into an absolute path.
   * 
   * The given sequence of paths is processed from right to left, with each subsequent `path` prepended
   * until an absolute path is constructed. For instance, given the sequence of path segments:
   * `'/foo'`, `'/bar'`, `'baz'`, calling `resolve('/foo', '/bar', 'baz')` would return `'/bar/baz'`.
   * 
   * If after processing all given path segments an absolute path has not yet been generated, `'/'` is used.
   * 
   * The resulting path is normalized and trailing slashes are removed unless the path is resolved to the
   * root directory.
   * 
   * Zero-length path segments are ignored.
   * 
   * If no path segments are passed, path.resolve() will return the absolute path of the current working
   * directory.
   * 
   * **Note:** This method is derived from
   * [`path.resolve`]( https://github.com/nodejs/node/blob/master/lib/path.js) method of NodeJS.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @param {...String} paths A sequence of paths or path segments.
   * @returns {String} The resolved absolute path.
   * @see https://nodejs.org/dist/latest-v8.x/docs/api/path.html#path_path_resolve_paths
   * @see https://nodejs.org/dist/latest-v8.x/docs/api/path.html#path_path_join_paths
   * @example
   * 
   * _.resolvePath('/foo/bar', './baz')
   * // => '/foo/bar/baz'
   * 
   * _.resolvePath('/foo/bar', '/tmp/file/')
   * // => '/tmp/file'
   * 
   * _.resolvePath('wwwroot', 'static_files/png/', '../gif/image.gif')
   * // => '/wwwroot/static_files/gif/image.gif'
   */
  function resolvePath(paths) {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0) {
        path = arguments[i];
      } else {
        if (cwd === undefined) {
          cwd = '/';
        }
        path = cwd;
      }
      path = String(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe.

    // Normalize the path
    resolvedPath = normalizePathPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  }

  /**
   * A detection method to check if the environment is fit for Springfield.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   */
  function detectEnvironment() {
    if (typeof springfield === 'undefined'
        || Object.prototype.toString.call(springfield) !== '[object Object]') {
      throw new ReferenceError('Springfield is required');
    }
  }

  /**
   * A library that delivers several web-related constants/methods to Springfield.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @borrows contextPath as Springfield.prototype.CONTEXT_PATH
   * @borrows browserDetector.userAgent as Springfield.prototype.USER_AGENT
   * @borrows browserDetector.isIE as Springfield.prototype.IS_IE
   * @borrows browserDetector.isEdge as Springfield.prototype.IS_EDGE
   * @borrows browserDetector.isFirefox as Springfield.prototype.IS_FIREFOX
   * @borrows browserDetector.isChrome as Springfield.prototype.IS_CHROME
   * @borrows browserDetector.isAndroid as Springfield.prototype.IS_ANDROID
   * @borrows browserDetector.isIOS as Springfield.prototype.IS_IOS
   * @borrows browserDetector.isPostMessageAvailable as Springfield.prototype.IS_POST_MESSAGE_AVAILABLE
   * @borrows browserDetector.isDragAndDropAvailable as Springfield.prototype.IS_DRAG_AND_DROP_AVAILABLE
   * @borrows browserDetector.isFileAvailable as Springfield.prototype.IS_FILE_AVAILABLE
   * @borrows browserDetector.isGeolocationAvailable as Springfield.prototype.IS_GEOLOCATION_AVAILABLE
   * @borrows browserDetector.isHistoryAvailable as Springfield.prototype.IS_HISTORY_AVAILABLE
   * @borrows browserDetector.isBackAvailable as Springfield.prototype.isBackAvailable
   * @borrows browserDetector.isLocalStorageAvailable as Springfield.prototype.IS_LOCAL_STORAGE_AVAILABLE
   * @borrows browserDetector.isMicrodataAvailable as Springfield.prototype.IS_MICRODATA_AVAILABLE
   * @borrows browserDetector.isSessionStorageAvailable as Springfield.prototype.IS_SESSION_STORAGE_AVAILABLE
   * @borrows browserDetector.isCORSAvailable as Springfield.prototype.IS_CORS_AVAILABLE
   * @borrows browserDetector.isFormDataAvailable as Springfield.prototype.IS_FORM_DATA_AVAILABLE
   * @borrows escape as Springfield.prototype.escape
   * @borrows unescape as Springfield.prototype.unescape
   * @borrows normalizePath as Springfield.prototype.normalizePath
   * @borrows isURLLikeString as Springfield.prototype.isURLLikeString
   * @borrows isURL as Springfield.prototype.isURL
   * @borrows getQuery as Springfield.prototype.getQuery
   * @borrows getQueryParams as Springfield.prototype.getQueryParams
   * @borrows route as Springfield.prototype.route
   * @borrows resolvePath as Springfield.prototype.resolvePath
   */
  function extendSpringfield() {
    Object.defineProperties(springfield.fn, {
      'CONTEXT_PATH': { value: contextPath, enumerable: true },
      'USER_AGENT': { get: function() { return browserDetector.userAgent }, enumerable: true }, // 如果像contextPath一样直接设成常量的话，那么这些用来侦测浏览器支持状况的表达式
      'IS_IE': { get: function() { return browserDetector.isIE }, enumerable: true },           // 会在画面初始化的时候全部执行一遍，显然不是所有的画面都需要，全执行的话有点浪费性能。
      'IS_EDGE': { get: function() { return browserDetector.isEdge }, enumerable: true },       // 但做成函数，又会导致每次调用后重算结果，而实际上这些值并不会再次变更。
      'IS_FIREFOX': { get: function() { return browserDetector.isFirefox }, enumerable: true }, // 因此声明了一个类（BrowserDetector）专门用来侦测并缓存结果。当用户需要时，通过
      'IS_CHROME': { get: function() { return browserDetector.isChrome }, enumerable: true },   // Springfield上相关get方法调用此类的缓存结果即可。而Springfield上定义的是get方法，
      'IS_ANDROID': { get: function() { return browserDetector.isAndroid }, enumerable: true }, // 其表现形式与常量相当，保证了对外的一致性。
      'IS_IOS': { get: function() { return browserDetector.isIOS }, enumerable: true },
      'IS_POST_MESSAGE_AVAILABLE': { get: function() { return browserDetector.isPostMessageAvailable }, enumerable: true },  // 另一种等价方案是在立即执行函数体中声明一个空对象用以缓存
      'IS_DRAG_AND_DROP_AVAILABLE': { get: function() { return browserDetector.isDragAndDropAvailable }, enumerable: true }, // 侦测结果，然后声明一系列侦测函数，最后为Springfield定义
      'IS_FILE_AVAILABLE': { get: function() { return browserDetector.isFileAvailable }, enumerable: true },                 // getter时作判断，如果缓存中没有结果就调用之前声明的函数，
      'IS_GEOLOCATION_AVAILABLE': { get: function() { return browserDetector.isGeolocationAvailable }, enumerable: true },   // 把结果放入缓存后由getter进行return。
      'IS_HISTORY_AVAILABLE': { get: function() { return browserDetector.isHistoryAvailable }, enumerable: true },           // 和现行方案相比，结构简单但分散，考虑到维护性，因此未采用。
      'isBackAvailable': { get: function() { return browserDetector.isBackAvailable }, enumerable: true },
      'IS_LOCAL_STORAGE_AVAILABLE': { get: function() { return browserDetector.isLocalStorageAvailable }, enumerable: true },
      'IS_MICRODATA_AVAILABLE': { get: function() { return browserDetector.isMicrodataAvailable }, enumerable: true },
      'IS_SESSION_STORAGE_AVAILABLE': { get: function() { return browserDetector.isSessionStorageAvailable }, enumerable: true },
      'IS_CORS_AVAILABLE': { get: function() { return browserDetector.isCORSAvailable }, enumerable: true },
      'IS_FORM_DATA_AVAILABLE': { get: function() { return browserDetector.isFormDataAvailable }, enumerable: true },
      'isCookieEnabled': { get: function() { return window.navigator.cookieEnabled }, enumerable: true },
      'escape': { value: escape, configurable: true, enumerable: true, writable: true },
      'unescape': { value: unescape, configurable: true, enumerable: true, writable: true },
      'normalizePath': { value: normalizePath, configurable: true, enumerable: true, writable: true },
      'isURLLikeString': { value: isURLLikeString, configurable: true, enumerable: true, writable: true },
      'isURL': { value: isURL, configurable: true, enumerable: true, writable: true },
      'getQuery': { value: getQuery, configurable: true, enumerable: true, writable: true },
      'getQueryParams': { value: getQueryParams, configurable: true, enumerable: true, writable: true },
      'route': { value: route, configurable: true, enumerable: true, writable: true },
      'resolvePath': { value: resolvePath, configurable: true, enumerable: true, writable: true },
    });
  }

  detectEnvironment();
  extendSpringfield();
})();
