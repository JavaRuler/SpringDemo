/**
 * @license
 * Copyright © 2017 ∑(O_O；).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * A polyfill of `Array.isArray`.
 * 
 * Running the following code before any other code will create `Array.isArray` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
 */
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

/**
 * A polyfill of `Array.of`.
 * 
 * Running the following code before any other code will create `Array.of()` if it's not natively
 * available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
 */
if (!Array.of) {
  Array.of = function() {
    return Array.prototype.slice.call(arguments);
  };
}

/**
 * A polyfill of `Array.prototype.every`.
 * 
 * Method `every` was added to the ECMA-262 standard in the 5th edition; as such it may not be
 * present in other implementations of the standard. You can work around this by inserting the
 * following code at the beginning of your scripts, allowing use of `every` in implementations
 * which do not natively support it. This algorithm is exactly the one specified in ECMA-262,
 * 5th edition, assuming `Object` and `TypeError` have their original values and that `callbackfn.call`
 * evaluates to the original value of `Function.prototype.call`.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
 */
if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError(); // TODO 改用Object.prototype.toString判断
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list 
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}

/**
 * A polyfill of `Array.prototype.forEach`.
 * 
 * Method `forEach` was added to the ECMA-262 standard in the 5th edition; as such it may not be
 * present in other implementations of the standard. You can work around this by inserting the
 * following code at the beginning of your scripts, allowing use of `forEach` in implementations
 * that don't natively support it. This algorithm is exactly the one specified in ECMA-262,
 * 5th edition, assuming `Object` and `TypeError` have their original values and that `callback.call`
 * evaluates to the original value of `Function.prototype.call`.
 * 
 * Production steps of ECMA-262, Edition 5, 15.4.4.18
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
 * @see http://es5.github.io/#x15.4.4.18
 */
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback/*, thisArg*/) {

    var T, k;

    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat while k < len.
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator.
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c.
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined.
  };
}

/**
 * A polyfill of `Array.prototype.includes`.
 * 
 * Running the following code before any other code will create `Array.prototype.includes`
 * if it's not natively available.
 * 
 * **Note:** If you need to support truly obsolete JavaScript engines that don't support
 * `Object.defineProperty`, it's best not to polyfill `Array.prototype` methods at all,
 * as you can't make them non-enumerable.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes
 * @see https://tc39.github.io/ecma262/#sec-array.prototype.includes
 */
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function(searchElement, fromIndex) {

      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      // 6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      function sameValueZero(x, y) {
        return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
      }

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        // c. Increase k by 1. 
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        k++;
      }

      // 8. Return false
      return false;
    }
  });
}

/**
 * A polyfill of `Array.prototype.map`.
 * 
 * Method `map` was added to the ECMA-262 standard in the 5th edition; as such it may not be
 * present in all implementations of the standard. You can work around this by inserting the
 * following code at the beginning of your scripts, allowing use of `map` in implementations
 * which do not natively support it. This algorithm is exactly the one specified in ECMA-262,
 * 5th edition, assuming `Object`, `TypeError`, and `Array` have their original values and that
 * `callback.call` evaluates to the original value of `Function.prototype.call`.
 * 
 * Production steps of ECMA-262, Edition 5, 15.4.4.19
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
 * @see http://es5.github.io/#x15.4.4.19
 */
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal 
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let A be a new array created as if by the expression new Array(len) 
    //    where Array is the standard built-in constructor with that name and 
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal 
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal 
        //     method of callback with T as the this value and argument 
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}

/**
 * A polyfill of `Array.prototype.reduce`.
 * 
 * Running the following code before any other code will create `Array.prototype.reduce` if it's not
 * natively available.
 * 
 * **Note:** If you need to support truly obsolete JavaScript engines that don't support `Object.defineProperty`,
 * it's best not to polyfill `Array.prototype` methods at all, as you can't make them non-enumerable.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
 * @see https://tc39.github.io/ecma262/#sec-array.prototype.reduce
 */
if (!Array.prototype.reduce) {
  Object.defineProperty(Array.prototype, 'reduce', {
    value: function(callback /*, initialValue*/) {
      if (this === null) {
        throw new TypeError( 'Array.prototype.reduce ' + 
          'called on null or undefined' );
      }
      if (typeof callback !== 'function') {
        throw new TypeError( callback +
          ' is not a function');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0; 

      // Steps 3, 4, 5, 6, 7      
      var k = 0; 
      var value;

      if (arguments.length >= 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in o)) {
          k++; 
        }

        // 3. If len is 0 and initialValue is not present,
        //    throw a TypeError exception.
        if (k >= len) {
          throw new TypeError( 'Reduce of empty array ' +
            'with no initial value' );
        }
        value = o[k++];
      }

      // 8. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kPresent be ? HasProperty(O, Pk).
        // c. If kPresent is true, then
        //    i.  Let kValue be ? Get(O, Pk).
        //    ii. Let accumulator be ? Call(
        //          callbackfn, undefined,
        //          « accumulator, kValue, k, O »).
        if (k in o) {
          value = callback(value, o[k], k, o);
        }

        // d. Increase k by 1.      
        k++;
      }

      // 9. Return accumulator.
      return value;
    }
  });
}

/**
 * A polyfill of `Array.prototype.some`.
 * 
 * Method `some` was added to the ECMA-262 standard in the 5th edition; as such it may not be
 * present in all implementations of the standard. You can work around this by inserting the
 * following code at the beginning of your scripts, allowing use of `some` in implementations
 * which do not natively support it. This algorithm is exactly the one specified in ECMA-262,
 * 5th edition, assuming `Object` and `TypeError` have their original values and that `fun.call`
 * evaluates to the original value of `Function.prototype.call`.
 * 
 * Production steps of ECMA-262, Edition 5, 15.4.4.17
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
 * @see http://es5.github.io/#x15.4.4.17
 */
if (!Array.prototype.some) {
  Array.prototype.some = function(callback/*, thisArg*/) {
    'use strict';

    if (this == null) {
      throw new TypeError('Array.prototype.some called on null or undefined');
    }

    if (typeof callback !== 'function') {
      throw new TypeError('The "callback" argument of Array.prototype.some must be a function');
    }

    var t = Object(this);
    var len = t.length >>> 0;

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t && callback.call(thisArg, t[i], i, t)) {
        return true;
      }
    }

    return false;
  };
}

/**
 * A polyfill of `Element.prototype.matches`.
 * 
 * For browsers that do not support `Element.matches` or `Element.matchesSelector`, 
 * but carry support for `document.querySelectorAll`.
 * 
 * **Note:** Several browsers implement this, prefixed, under the non-standard name `matchesSelector`.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 */
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector
      || Element.prototype.mozMatchesSelector
      || Element.prototype.msMatchesSelector
      || Element.prototype.oMatchesSelector
      || Element.prototype.webkitMatchesSelector
      || function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s);
        var i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;            
      };
}
Element.prototype.matchesSelector = Element.prototype.matches;

/**
 * A polyfill of `Function.prototype.bind`.
 * 
 * You can partially work around this by inserting the following code at the beginning of your
 * scripts, allowing use of much of the functionality of `bind` in implementations that do not
 * natively support it.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
if (!Function.prototype.bind) {
  Function.prototype.bind = function(that) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var args = Array.prototype.slice.call(arguments, 1);
    var toBind = this;
    var NoOp = function() {};
    var Bound = function() {
      return toBind.apply(
            this instanceof NoOp ? this : that,
            args.concat(Array.prototype.slice.call(arguments))
      );
    };

    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      NoOp.prototype = this.prototype; 
    }
    Bound.prototype = new NoOp();
    return Bound;
  };
}

/**
 * A polyfill of `Number.MAX_SAFE_INTEGER`.
 * 
 * Running the following code before any other code will create `Number.MAX_SAFE_INTEGER` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
 */
if (!Number.MAX_SAFE_INTEGER) {
  Object.defineProperty(Number, 'MAX_SAFE_INTEGER', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: Math.pow(2, 53) - 1
  });
}

/**
 * A polyfill of `Number.MIN_SAFE_INTEGER`.
 * 
 * Running the following code before any other code will create `Number.MIN_SAFE_INTEGER` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER
 */
if (!Number.MIN_SAFE_INTEGER) {
  Object.defineProperty(Number, 'MIN_SAFE_INTEGER', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: -(Math.pow(2, 53) - 1)
  });
}

/**
 * A polyfill of `Number.isFinite`.
 * 
 * Running the following code before any other code will create `Number.isFinite` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
 */
if (!Number.isFinite) {
  Number.isFinite = function(value) {
    return typeof value === 'number' && isFinite(value);
  }
}

/**
 * A polyfill of `Number.isInteger`.
 * 
 * Running the following code before any other code will create `Number.isInteger` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
if (!Number.isInteger) {
  Number.isInteger = function(value) {
    return typeof value === 'number'
        && isFinite(value)
        && Math.floor(value) === value;
  };
}

/**
 * A polyfill of `Number.isNaN`.
 * 
 * Running the following code before any other code will create `Number.isNaN` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
 */
if (!Number.isNaN) {
  Number.isNaN = function(value) {
    return typeof value === 'number' && isNaN(value);
  }
}

/**
 * A polyfill of `Number.isSafeInteger`.
 * 
 * Running the following code before any other code will create `Number.isSafeInteger` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
 */
if (!Number.isSafeInteger) {
  Number.isSafeInteger = function (value) {
    return Number.isInteger(value) && Math.abs(value) <= Number.MAX_SAFE_INTEGER;
  };
}

/**
 * A polyfill of `Number.parseFloat`.
 * 
 * Running the following code before any other code will create `Number.parseFloat` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat
 */
if (!Number.parseFloat) {
  Number.parseFloat = parseFloat;
}

/**
 * A polyfill of `Number.parseInt`.
 * 
 * Running the following code before any other code will create `Number.parseInt` if it's not
 * natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt
 */
if (!Number.parseInt) {
  Number.parseInt = parseInt;
}

/**
 * A polyfill of `String.prototype.endsWith`.
 * 
 * This method has been added to the ECMAScript 6 specification and may not be available in
 * all JavaScript implementations yet. However, you can polyfill `String.prototype.endsWith`
 * with the following snippet:
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
 */
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(searchStr, position) {
    // This works much better than >= because
    // it compensates for NaN:
    if (!(position < this.length)) {
      position = this.length;
    } else {
      position |= 0; // round position
    }
    return this.substr(position - searchStr.length, searchStr.length) === searchStr;
  };
}

/**
 * A polyfill of `String.prototype.includes`.
 * 
 * This method has been added to the ECMAScript 2015 specification and may not be available in
 * all JavaScript implementations yet. However, you can easily polyfill this method:
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
 */
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    'use strict';
    if (typeof start !== 'number') {
      start = 0;
    }
    
    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}

/**
 * A polyfill of `String.prototype.startsWith`.
 * 
 * This method has been added to the ECMAScript 2015 specification and may not be available in
 * all JavaScript implementations yet. However, you can polyfill `String.prototype.startsWith`
 * with the following snippet:
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
 */
if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
      return this.substr(position || 0, searchString.length) === searchString;
  };
}

/**
 * A polyfill of `String.prototype.trim`.
 * 
 * Running the following code before any other code will create `trim` if it's not natively available.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim
 */
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };
}

/**
 * A polyfill of `Object.assign`.
 * 
 * Running the following code before any other code will create `Object.assign` if it's not
 * natively available.
 * 
 * **Note:** This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
if (!Object.assign) {
  Object.assign = function(target, varArgs) { // .length of function is 2
    'use strict';
    if (target == null) { // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];

      if (nextSource != null) { // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

/**
 * A polyfill of `Object.create`.
 * 
 * This polyfill covers the main use case which is creating a new object for which the
 * prototype has been chosen but doesn't take the second argument into account.
 * 
 * **Note:** While the setting of `null` as `[[Prototype]]` is supported in the real ES5
 * `Object.create`, this polyfill cannot support it due to a limitation inherent in versions of
 * ECMAScript lower than 5.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
 */
if (!Object.create) {
  Object.create = function (proto, propertiesObject) {
    if (!(proto === null || typeof proto === 'object' || typeof proto === 'function')) {
      throw TypeError('Argument must be an object, or null');
    }
    var temp = new Object();
    temp.__proto__ = proto;
    Object.defineProperties(temp, propertiesObject);
    return temp;
  };
}

/**
 * A polyfill of `Object.defineProperties`.
 * 
 * Assuming a pristine execution environment with all names and properties referring to 
 * their initial values, `Object.defineProperties` is almost completely equivalent (note the 
 * comment in isCallable) to the following reimplementation in JavaScript.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties
 */
if (!Object.defineProperties) {
  Object.defineProperties = function (obj, properties) {
    function convertToDescriptor(desc) {
      function hasProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      function isCallable(v) {
        // NB: modify as necessary if other values than functions are callable.
        return typeof v === 'function';
      }

      if (typeof desc !== 'object' || desc === null) {
        throw new TypeError('bad desc');
      }

      var d = {};

      if (hasProperty(desc, 'enumerable')) {
        d.enumerable = !!desc.enumerable;
      }
      if (hasProperty(desc, 'configurable')) {
        d.configurable = !!desc.configurable;
      }
      if (hasProperty(desc, 'value')) {
        d.value = desc.value;
      }
      if (hasProperty(desc, 'writable')) {
        d.writable = !!desc.writable;
      }
      if (hasProperty(desc, 'get')) {
        var g = desc.get;

        if (!isCallable(g) && typeof g !== 'undefined') {
          throw new TypeError('bad get');
        }
        d.get = g;
      }
      if (hasProperty(desc, 'set')) {
        var s = desc.set;
        if (!isCallable(s) && typeof s !== 'undefined') {
          throw new TypeError('bad set');
        }
        d.set = s;
      }
      if (('get' in d || 'set' in d) && ('value' in d || 'writable' in d)) {
        throw new TypeError('identity-confused descriptor');
      }

      return d;
    }

    if (typeof obj !== 'object' || obj === null) {
      throw new TypeError('bad obj');
    }

    properties = Object(properties);
    var keys = Object.keys(properties);
    var descs = [];

    for (var i = 0; i < keys.length; i++) {
      descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);
    }

    for (var i = 0; i < descs.length; i++) {
      Object.defineProperty(obj, descs[i][0], descs[i][1]);
    }

    return obj;
  }
}

/**
 * A polyfill of `Object.keys`.
 * 
 * To add compatible `Object.keys` support in older environments that do not natively support it.
 * 
 * **Note:** The code shown below includes non-enumerable keys in IE7 (and maybe IE8), when passing
 * in an object from a different window.
 * 
 * @since 1.0.0
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
 */
if (!Object.keys) {
  Object.keys = (function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    return function(obj) {
      if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}
