/**
 * @license
 * Copyright © 2017 ∑(O_O；).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

'use strict';

(function() {

  // Used to check if the property can be mixed in.
  var noMixins = ['conflict', 'fn', 'require', 'mixin', 'noConflict', '_'];

  /**
   * A method that checks if the specified properties are all avaliable.
   * 
   * **Note:** If any of the specified properties is unavaliable, Error will be thrown.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @instance
   * @param {...*} args Names of the specified properties.
   * @example
   * 
   * _.require('aMethod')
   * // => Uncaught ReferenceError: Springfield.a is required
   */
  function require(args) {
    if (arguments.length === 0) {
      return;
    }

    var dependency;
    var self = this;
    var isAnyUnavailable = Array.apply(null, arguments).some(function(argument) {
      if (!self.fn.hasOwnProperty(argument)) {
        dependency = argument;
        return true;
      }
      return false;
    });

    if (isAnyUnavailable) {
      throw new ReferenceError('Springfield.' + dependency + ' is required');
    }
  }

  /**
   * A method that mixins modules/functions into `springfield`, or shadows any property of `springfield`'s
   * prototype.
   * 
   * **Note:** The following properties will not be effected:
   * - conflict
   * - conflict._
   * - fn
   * - require
   * - mixin
   * - noConflict
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @instance
   * @param {*} source The property to mixin.
   * @param {*} [name] The name of property. Can be `null` if the `source` is object-like.
   * @example
   * 
   * _.mixin(1, 'isNumber')
   * // => add a property named 'isNumber' to `springfield`
   * 
   * _.mixin({ isNumber: 1 })
   * // => add a property named 'isNumber' to `springfield`
   */
  function mixin(source, name) {
    if (source == null) {
      return;
    }

    var self = this;
    var sourceName = name == null ? source.name : name;

    if (sourceName != null) {
      sourceName = String(sourceName);
      if (noMixins.includes(sourceName)) {
        return;
      }
      // Avoid bugs when hasOwnProperty is shadowed
      if (Object.prototype.hasOwnProperty.call(self, sourceName)) {
        self.conflict[sourceName] = self[sourceName];
      }
      self[sourceName] = source;
      return;
    }

    if (typeof source === 'object') {
      Object.keys(source).forEach(function(key) {
        self.mixin(source[key], key);
      });
    }
  }

  /**
   * A method that relinquishes springfield’s control of the `_` variable.
   * 
   * Many JavaScript libraries use `_` as a function or variable name, just as springfield does.
   * In springfield's case, `_` is just an alias for springfield, so all functionality is available
   * without using `_`. If you need to use another JavaScript library alongside springfield, return
   * control of `_` back to the other library with a call to `_.noConflict()`. Old reference of `_`
   * is saved during springfield initialization; `noConflict` simply restores it.
   * 
   * @author ∑(O_O；)
   * @since 1.0.0
   * @method
   * @memberof Springfield
   * @instance
   * @returns {Object} The `springfield` itself.
   * @example
   * 
   * _.noConflict()
   * // => Springfield {conflict: Object, fn: Object, require: function, mixin: function, noConflict: function…}
   */
  function noConflict() {
    var conflictAlias = this.conflict._;
    if (conflictAlias && conflictAlias != this) {
      window._ = conflictAlias;
    }
    return this;
  }

  /**
   * A JavaScript utility library delivering modularity, performance, & extras.
   * 
   * @author ∑(O_O；)
   * @version 1.0.0
   * @class
   */
  function Springfield() {
    if (typeof window === 'undefined' || Object.prototype.toString.call(window) !== '[object Window]') {
      throw new ReferenceError('The "window" object is required');
    }
    if (typeof springfield !== 'undefined') {
      throw new ReferenceError('Springfield already exists');
    }

    Object.defineProperties(this, {
      'VERSION': { value: '1.0.0' },
      'conflict': { value: Object.create(null), enumerable: true },
      'fn': { value: Object.getPrototypeOf(this), enumerable: true },
      'require': { value: require, enumerable: true },
      'mixin': { value: mixin.bind(this), enumerable: true },
      'noConflict': { value: noConflict.bind(this), enumerable: true },
    });

    if (window._ && Object.getPrototypeOf(window._) !== this.fn) {
      this.conflict._ = window._;
    }
  }

  window.springfield = window._ = new Springfield();
})();
